package class15;

/*
题意：
int numIslands(char[][] board) {}，在岛问题1中，如果board极大，设计一种可行的并行计算方案

 */
/*
时间
题意：1:56
题解：2：00
 */
/*
思维导图
1.在岛问题1中，我们是遍历board，如果当前位置是'1'，就看左边和上边是不是1，是就合并。如果board极大，需要一种并行计算方案
2.先假设2个cpu，我们先在中间切一刀
    因为这一刀的存在可能会使原本连通的岛被人为的断开，只可能产生更多的岛，而不可能变少
3.2个CPU求自己岛数量可以去递归感染或者并查集都可以，在感染过程中一方面要求岛的数量，另外一方面如果当前位置是边界，并且要被感染，那么就要记录一个信息，当前位置最开始是被哪个点感染的
4. 2个cpu跑完会得到两边的岛数量，以及边界是被谁感染的
5. 处理边界，只处理左右边界都被感染了的情况，比如左边当初是被A感染的，右边当初是被B感染的，建立并查集，发现A和B不是同一个集合，就合并，然后岛数量--。
如果没有这一刀，左右两边其实是连通的，我们因为这一刀多算了，所以又通过并查集，去合并那些原本应该是一个岛的集合。
 */

public class Code04_岛问题并行计算 {
}
