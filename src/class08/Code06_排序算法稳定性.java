package class08;


/*
 [题意]
 排序算法稳定性、总结
*/

/*
[时间]

常见的排序算法的坑：1:17

 */

/**
 1.定义
 稳定性是指同样大小的样本再排序之后不会改变相对次序。 比如[7,2,3,7] ,排完序之后，第4个7不会跑到第1个7前面
 稳定性在基础数据类型中毫无软用；但是在非基础数据类型中就很有用
 举个例子：
 每个学生有班级和年龄两个属性。
 第一回排序：所有年龄从小到大排序
 在第一回排序的基础上，按班级号从小到达排序
 如果有稳定性的话，在班级号中，1班，2班，3班。。。每一个班级中的学生一定是按照年龄从小到达排序的。

 生活中的例子：
 购物的时候，点击价格从小到大排序，再点击所有物品按照好评度排序。如果有稳定性，此时的物品就是物美价廉。

 有些排序算法可以优化成有稳定性的，有些排序算法无论如何都没有稳定性

 2.
 时间复杂度           空间复杂度   有无稳定性
 选择排序        o(n^2)              O(1)        无
 冒泡排序        o(n^2)              O(1)        有
 插入排序        o(n^2)              O(1)        有

 归并排序        o(nlogn)            O(n)        有
 快速排序        o(nlogn)            O(logn)     无
 堆排序          o(nlogn)            O(1)        无

 计数排序        o(N)                O(M)        有
 基数排序        log(10,max) * n     O(n)        有

 选择排序最捞！拼常数时间，快排最好。



 3.时间愎杂度O(N*OgN)、额外空间复杂度低于O(N)、且稳定的基于比较的.排序是不存在的。
 为了绝对的速度选快排、为了省空间选堆排、为了稳定性选归并


 4.常见的坑：[1:17]
 1)归并排序的额外空间复杂度可以变成0(1)，“归并排序内部缓存法”，但是将变得不再稳定。 -> 你要真图空间，用堆排序不好吗？
 2)“原地归并排序"是垃圾贴，会让时间复杂度变成O(n^2) -> 时间复杂度都o(N^2)了，纯垃圾
 3)快速排序稳定性改进，“01 stable sort”,但是会对样本数据要求更多。 -> 数据状况都要求了，我用桶排序不香吗？
 4)在整型数组中，请把奇数放在数组左边，偶数放在数组右边，要求所有奇数之间原始的相对次序不变，所有偶数之间原始相对次序不变。
 时间复杂度做到ON),额外空间复杂度做到O(1)
 -> partiton中，第一种是<=x放左边,>x放右边，这是一种0 1标准，这道题无非就是奇数放左，偶数放右，这也是0 1标准，如果真的纯在题目要求的，时复O(n)，空复O(1), 还稳定，那快排岂不是爽飞了，
 你就找到一个时复O(n*logn), 空复O(logn), 还稳定的排序，那你就去拿图灵奖吧


 5.工程上堆排序的改进
 ①从稳定性的考虑：如：在java中，Arrays.sort()方法如果形参是基础数据类型，它底层才用快排，如果形参不是基础数据类型，它不知道你要不要求稳定，底层只好采用归并排序。
 ②充分利用O(N*logN)和O(N^2)排序各自的优势：这个我们用代码解释：
 系统底层的快排：如果数据量<60会用插入排序去执行。
 原因：
 N很大的时候：快排肯定更快
 N小的时候：用插入排序很有可能更快，n很小的时候，其实时间复杂度没那么重要，反而常数时间好的会快


*/
 public class Code06_排序算法稳定性 {
}
